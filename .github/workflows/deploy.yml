name: Deploy n8n (GitHub Actions)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  issues: write
  pull-requests: write
  packages: write
  statuses: write
  actions: read

env:
  ACTIONS_RUNNER_DEBUG: true
  ACTIONS_STEP_DEBUG: true
  DOCKER_REGISTRY: registry.digitalocean.com
  DROPLET_NAME: n8n-server
  N8N_VERSION: latest
  N8N_BASIC_AUTH_USER: admin
  # Senha simples para ambiente de teste (usu√°rio: admin, senha: teste123)
  N8N_TEST_PASSWORD: "teste123"
  # Chave de criptografia padr√£o para ambiente de teste
  N8N_TEST_ENCRYPTION_KEY: "12345678901234567890123456789012"
  # Dom√≠nio padr√£o
  N8N_DOMAIN: "n8n.pepper88.com"

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      is_test_env: ${{ steps.check_env.outputs.is_test }}
      auth_password: ${{ steps.check_env.outputs.password }}
      encryption_key: ${{ steps.encryption_key.outputs.key }}
      domain: ${{ steps.check_env.outputs.domain }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate or Get Encryption Key
        id: encryption_key
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Em produ√ß√£o, usa a chave configurada ou gera uma nova
            if [ -n "${{ secrets.N8N_ENCRYPTION_KEY }}" ]; then
              echo "key=${{ secrets.N8N_ENCRYPTION_KEY }}" >> $GITHUB_OUTPUT
              echo "üîê Using configured encryption key"
              echo "Debug: Key length: ${#N8N_ENCRYPTION_KEY}"
            else
              # Gera uma nova chave hexadecimal de 32 caracteres
              new_key=$(openssl rand -hex 16)
              echo "key=$new_key" >> $GITHUB_OUTPUT
              echo "üîê Generated new encryption key: $new_key"
              echo "Debug: Key length: ${#new_key}"
              echo "‚ö†Ô∏è Important: Save this key in your repository secrets for future use!"
            fi
          else
            # Em teste, usa a chave padr√£o
            echo "key=${{ env.N8N_TEST_ENCRYPTION_KEY }}" >> $GITHUB_OUTPUT
            echo "üîë Using test encryption key"
            echo "Debug: Key length: ${#N8N_TEST_ENCRYPTION_KEY}"
          fi
          
          # Valida√ß√£o adicional
          key_value=$(cat $GITHUB_OUTPUT | grep "^key=" | cut -d= -f2)
          if [ -z "$key_value" ]; then
            echo "‚ùå Error: Encryption key is empty"
            exit 1
          fi
          echo "‚úÖ Encryption key validation passed"

      - name: Check environment
        id: check_env
        run: |
          echo "Debug: Current branch is ${{ github.ref }}"
          echo "Debug: N8N_DOMAIN env var is ${{ env.N8N_DOMAIN }}"
          
          # Determina se √© ambiente de teste baseado na branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "is_test=false" >> $GITHUB_OUTPUT
            echo "password=${{ secrets.N8N_BASIC_AUTH_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "domain=${{ env.N8N_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "Debug: Setting domain output to ${{ env.N8N_DOMAIN }} (production)"
            echo "üîí Production environment detected - using secure password"
            echo "üåê Using domain: ${{ env.N8N_DOMAIN }}"
          else
            echo "is_test=true" >> $GITHUB_OUTPUT
            echo "password=${{ env.N8N_TEST_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "domain=${{ env.N8N_DOMAIN }}" >> $GITHUB_OUTPUT
            echo "Debug: Setting domain output to ${{ env.N8N_DOMAIN }} (test)"
            echo "‚ö†Ô∏è Test environment detected - using simple password (teste123)"
            echo "üåê Using domain: ${{ env.N8N_DOMAIN }}"
          fi

      - name: Validate DigitalOcean Token
        run: |
          echo "üîç Testing DigitalOcean API Token..."
          response=$(curl -s -X GET \
            -H "Authorization: Bearer ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" \
            "https://api.digitalocean.com/v2/account")
          
          if echo "$response" | jq -e '.account' >/dev/null; then
            echo "‚úÖ DigitalOcean API Token is valid"
          else
            echo "‚ùå Error: Invalid DigitalOcean API Token"
            echo "Response: $response"
            exit 1
          fi

      - name: Validate Domain
        run: |
          echo "üîç Testing domain configuration..."
          domain="${{ steps.check_env.outputs.domain }}"
          echo "Debug: Raw domain value from output: '$domain'"
          echo "Debug: Domain length: ${#domain}"
          echo "Debug: Domain characters: $(echo "$domain" | od -c)"
          
          # Verifica se o dom√≠nio est√° vazio
          if [ -z "$domain" ]; then
            echo "‚ùå Error: Domain is empty"
            echo "Check if N8N_DOMAIN is set correctly"
            exit 1
          fi
          
          # Verifica o comprimento do dom√≠nio
          if [ ${#domain} -lt 4 ] || [ ${#domain} -gt 253 ]; then
            echo "‚ùå Error: Invalid domain length: ${#domain} characters"
            echo "Domain length should be between 4 and 253 characters"
            exit 1
          fi
          
          # Nova express√£o regular que suporta m√∫ltiplos n√≠veis de dom√≠nio
          if [[ ! "$domain" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
            echo "‚ùå Error: Invalid domain format"
            echo "Domain should be a valid hostname (e.g., n8n.example.com)"
            echo "Domain should:"
            echo "  - Start with a letter or number"
            echo "  - Contain only letters, numbers, dots, and hyphens"
            echo "  - End with a valid TLD"
            echo "  - Not exceed 253 characters"
            echo "Debug: Domain validation failed for: $domain"
            exit 1
          fi
          
          echo "‚úÖ Domain format is valid: $domain"
          
          # Em produ√ß√£o, verifica se o dom√≠nio resolve
          if [[ "${{ steps.check_env.outputs.is_test }}" != "true" ]]; then
            echo "Checking DNS resolution..."
            if ! host "$domain" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Warning: Domain $domain is not resolvable yet"
              echo "Make sure to configure DNS after deployment"
            else
              echo "‚úÖ DNS resolution successful for $domain"
            fi
          fi

      - name: Summary
        run: |
          echo "üéâ All validations passed!"
          echo "Environment: ${{ steps.check_env.outputs.is_test == 'true' && 'TEST' || 'PRODUCTION' }}"
          if [ "${{ steps.check_env.outputs.is_test }}" == "true" ]; then
            echo "‚ö†Ô∏è Using test credentials:"
            echo "  - Username: admin"
            echo "  - Password: teste123"
            echo "  - Domain: ${{ env.N8N_DOMAIN }}"
            echo "  - Encryption Key: ${{ env.N8N_TEST_ENCRYPTION_KEY }}"
          fi

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    env:
      N8N_DOMAIN: ${{ needs.validate.outputs.domain }}
      N8N_ENCRYPTION_KEY: ${{ needs.validate.outputs.encryption_key }}
      N8N_BASIC_AUTH_PASSWORD: ${{ needs.validate.outputs.auth_password }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Install dependencies
        run: |
          cd ci
          go mod download

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Configure Docker for DigitalOcean Registry
        run: |
          # Get registry name
          REGISTRY_NAME=$(doctl registry get --format Name --no-header)
          if [ -z "$REGISTRY_NAME" ]; then
            echo "‚ùå Error: Failed to get registry name"
            exit 1
          fi
          
          # Create Docker config directory if it doesn't exist
          mkdir -p ~/.docker
          
          # Configure Docker authentication for DigitalOcean registry
          if ! doctl registry login --expiry-seconds 600; then
            echo "‚ùå Error: Failed to login to registry"
            exit 1
          fi
          
          # Verify Docker authentication by trying to pull an image (if it exists)
          docker pull registry.digitalocean.com/$REGISTRY_NAME/n8n:latest || true

      - name: Create SSH key
        id: ssh_setup
        run: |
          echo "üîë Setting up SSH key..."
          
          # Create .ssh directory with correct permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Validate if SSH key secret exists
          if [ -z "${{ secrets.DO_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå Error: DO_SSH_PRIVATE_KEY secret is not set"
            echo "Please add your SSH private key as a repository secret"
            echo "You can generate it using: cat ~/.ssh/n8n_deploy | base64 -w 0"
            exit 1
          fi
          
          # Validate base64 format and content
          echo "Validating SSH key format..."
          KEY_CONTENT=$(echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" | base64 -d 2>/dev/null || true)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Error: Invalid base64 format in DO_SSH_PRIVATE_KEY"
            echo "Make sure you encoded the key correctly using:"
            echo "cat ~/.ssh/n8n_deploy | base64 -w 0"
            exit 1
          fi
          
          # Check if the decoded content looks like an SSH key
          if ! echo "$KEY_CONTENT" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "‚ùå Error: The decoded content doesn't look like an SSH private key"
            echo "The key should start with '-----BEGIN ... PRIVATE KEY-----'"
            echo "Please check if you're using the correct key file"
            exit 1
          fi
          
          # Write the SSH private key
          echo "Writing SSH key..."
          echo "$KEY_CONTENT" > ~/.ssh/id_rsa
          
          # Set correct permissions
          chmod 600 ~/.ssh/id_rsa
          
          # Add known hosts with error handling
          echo "Adding known hosts..."
          for host in "digitalocean.com" "registry.digitalocean.com"; do
            if ! ssh-keyscan -t rsa,ed25519 $host >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚ö†Ô∏è Warning: Failed to add $host to known_hosts"
            fi
          done
          
          # Set up ssh-agent
          echo "Starting ssh-agent..."
          if ! eval $(ssh-agent -s); then
            echo "‚ùå Error: Failed to start ssh-agent"
            exit 1
          fi
          
          # Add key to ssh-agent with validation
          echo "Adding key to ssh-agent..."
          if ! ssh-add ~/.ssh/id_rsa; then
            echo "‚ùå Error: Failed to add key to ssh-agent"
            echo "This usually means the key format is invalid"
            exit 1
          fi
          
          # Verify SSH key format and print information
          echo "Verifying SSH key details..."
          key_info=$(ssh-keygen -l -f ~/.ssh/id_rsa)
          if [ $? -eq 0 ]; then
            echo "‚úÖ SSH key information:"
            echo "$key_info"
          else
            echo "‚ùå Error: Invalid SSH key format"
            echo "Please make sure you're using a valid SSH private key"
            exit 1
          fi
          
          echo "‚úÖ SSH key setup completed successfully"

      - name: Deploy n8n
        env:
          DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          DO_SSH_KEY_FINGERPRINT: ${{ secrets.DO_SSH_KEY_FINGERPRINT }}
          DO_SSH_KEY_ID: ${{ secrets.DO_SSH_KEY_ID }}
          N8N_DOMAIN: ${{ needs.validate.outputs.domain }}
          N8N_ENCRYPTION_KEY: ${{ needs.validate.outputs.encryption_key }}
          N8N_BASIC_AUTH_USER: ${{ env.N8N_BASIC_AUTH_USER }}
          N8N_BASIC_AUTH_PASS: ${{ needs.validate.outputs.auth_password }}
        run: |
          echo "üöÄ Starting n8n deployment..."
          echo "Using domain: $N8N_DOMAIN"
          echo "Debug: Checking environment variables..."
          echo "- N8N_ENCRYPTION_KEY exists: ${{ needs.validate.outputs.encryption_key != '' }}"
          echo "- N8N_ENCRYPTION_KEY length: ${#N8N_ENCRYPTION_KEY}"
          
          cd ci
          if ! go run main.go; then
            echo "‚ùå Error: Failed to deploy n8n"
            echo "Debug information:"
            echo "- Domain: $N8N_DOMAIN"
            echo "- DO Token exists: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN != '' }}"
            echo "- SSH Key Fingerprint exists: ${{ secrets.DO_SSH_KEY_FINGERPRINT != '' }}"
            echo "- Encryption Key exists: ${{ needs.validate.outputs.encryption_key != '' }}"
            exit 1
          fi
          
          echo "‚úÖ n8n deployment completed successfully"

      - name: Verify Deployment
        run: |
          echo "üîç Verifying deployment..."
          domain="${{ needs.validate.outputs.domain }}"
          max_attempts=30
          attempt=1
          
          while ! curl -sf "https://$domain/healthz" > /dev/null; do
            if [ $attempt -ge $max_attempts ]; then
              echo "‚ùå Error: n8n health check failed after 5 minutes"
              exit 1
            fi
            echo "Waiting for n8n to be ready... attempt $attempt/$max_attempts"
            sleep 10
            ((attempt++))
          done
          
          echo "‚úÖ n8n is up and running at https://$domain"

      - name: Verify Database
        run: |
          echo "üîç Verifying database connection..."
          if ! docker exec n8n-db pg_isready -U n8n; then
            echo "‚ùå Error: Database connection failed"
            exit 1
          fi
          echo "‚úÖ Database connection verified"

      - name: Verify SSL Certificate
        run: |
          echo "üîç Verifying SSL certificate..."
          domain="${{ needs.validate.outputs.domain }}"
          
          # Check SSL certificate
          if ! curl -sI "https://$domain" | grep -i "HTTP/2 200" > /dev/null; then
            echo "‚ùå Error: SSL certificate verification failed"
            exit 1
          fi
          
          # Check certificate expiration
          expiry_days=$(curl -vI "https://$domain" 2>&1 | grep "expire date:" | awk '{print $4, $5, $6, $7, $8}')
          if [ -n "$expiry_days" ]; then
            echo "‚úÖ SSL certificate is valid until: $expiry_days"
          else
            echo "‚ö†Ô∏è Warning: Could not determine SSL certificate expiration"
          fi

      - name: Setup Monitoring
        run: |
          echo "üîß Setting up monitoring..."
          docker exec n8n-container /usr/local/bin/monitor.sh &
          echo "‚úÖ Monitoring started"

      - name: Setup Initial Backup
        run: |
          echo "üì¶ Creating initial backup..."
          if docker exec n8n-container /usr/local/bin/backup.sh; then
            echo "‚úÖ Initial backup created successfully"
          else
            echo "‚ö†Ô∏è Warning: Initial backup failed"
          fi

      - name: Deployment Summary
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üìù Summary:"
          echo "  - Application: https://${{ needs.validate.outputs.domain }}"
          echo "  - Environment: ${{ steps.check_env.outputs.is_test == 'true' && 'TEST' || 'PRODUCTION' }}"
          echo "  - Database: PostgreSQL"
          echo "  - Monitoring: Active"
          echo "  - Backup: Configured"
          echo "  - SSL: Verified"

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa*
